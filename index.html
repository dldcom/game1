<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>똥피하기 — Mobile Fixed</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;700;900&display=swap" rel="stylesheet">
<script src="https://cdn.tailwindcss.com"></script>
<style>
  :root{
    --glass-fill: rgba(255,255,255,0.12);
    --glass-stroke: rgba(255,255,255,0.35);
    --blur: 18px;
  }
  html, body{
    height:100%;
    overflow:hidden;           /* 스크롤 방지 */
    overscroll-behavior:none;  /* iOS/Android 당김 방지 */
    font-family: Inter, Pretendard, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    color:#111827;
    background-image:
      radial-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
      radial-gradient(rgba(0,0,0,0.035) 1px, transparent 1px),
      radial-gradient(1100px 900px at 15% 10%, rgba(255,255,255,0.08), transparent 60%),
      radial-gradient(1000px 900px at 85% 85%, rgba(0,0,0,0.22), transparent 60%),
      linear-gradient(135deg,#e5e7eb,#d1d5db);
    background-size:3px 3px,4px 4px,auto,auto,auto;
    background-blend-mode:overlay,overlay,normal,normal,normal;
  }
  .glass{
    background: var(--glass-fill);
    border: 1px solid var(--glass-stroke);
    box-shadow: inset 0 10px 30px rgba(0,0,0,.25), 0 10px 40px rgba(0,0,0,.2);
    backdrop-filter: blur(var(--blur));
    -webkit-backdrop-filter: blur(var(--blur));
    border-radius: 24px;
  }
  .btn-glass{
    background: var(--glass-fill);
    border: 1px solid var(--glass-stroke);
    box-shadow: 0 8px 24px rgba(0,0,0,.18);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border-radius: 16px;
    transition: transform .15s ease, box-shadow .15s ease;
    touch-action: manipulation; /* 모바일 더블탭 줌/스크롤 방지 */
  }
  .btn-glass:hover{ transform: translateY(-2px); box-shadow:0 14px 30px rgba(0,0,0,.22); }
  .btn-glass:active{ transform: scale(.98); }
  .btn-glass:focus-visible{ outline:none; box-shadow:0 0 0 3px rgba(147,197,253,.7), 0 8px 24px rgba(0,0,0,.18); }

  /* 9:16 세로 스테이지 */
  .stage {
    width: min(92vw, 420px);
    aspect-ratio: 9/16;
    position: relative;
    overflow: hidden;
    border-radius: 24px;
    /* 배경은 스테이지에 그려서 캔버스는 투명 유지 */
    background: linear-gradient(180deg,#ffffff 0%, #e5e7eb 100%);
  }

  .chip{
    background: rgba(255,255,255,.14);
    border: 1px solid var(--glass-stroke);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 999px;
    padding: 6px 12px;
    font-weight: 800;
    letter-spacing: -0.02em;
  }

  /* 하단 터치 영역 */
  .touch-zone{
    position:absolute; inset:auto 0 0 0; height:72px; display:flex; gap:12px; padding:12px;
    z-index: 30;                /* 버튼을 최상단에 표시 (항상 보이게) */
  }
  .touch-btn{
    flex:1;
    display:flex; align-items:center; justify-content:center;
    font-weight:900;
  }

  /* 결과 모달 */
  .modal{
    position:fixed; inset:0; display:grid; place-items:center; padding:24px;
    background: rgba(17,24,39,.35);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    opacity:0; visibility:hidden; transition:.2s ease;
  }
  .modal.show{ opacity:1; visibility:visible; }
</style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

  <main class="w-full max-w-[520px] space-y-4">
    <!-- 상단바 -->
    <header class="glass p-3 sm:p-4 flex items-center justify-between">
      <div class="flex items-center gap-3">
        <div class="size-9 rounded-xl bg-white/20 grid place-items-center border border-white/40 shadow-inner">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
            <circle cx="12" cy="12" r="9" stroke="#111827" stroke-width="1.5"/>
            <path d="M6 8c2-2 10-2 12 0" stroke="#a78bfa" stroke-width="2" fill="none" stroke-linecap="round"/>
          </svg>
        </div>
        <h1 class="text-lg sm:text-xl font-extrabold tracking-tight">똥피하기</h1>
      </div>
      <div class="flex items-center gap-2">
        <button id="btnPause" class="btn-glass px-3 py-2" aria-label="일시정지/재개 (P)">
          <span class="text-sm font-bold">⏯</span>
        </button>
        <button id="btnReset" class="btn-glass px-3 py-2" aria-label="다시시작 (R)">
          <span class="text-sm font-bold">↻</span>
        </button>
      </div>
    </header>

    <!-- 게임 -->
    <section class="glass p-3 sm:p-4 flex justify-center">
      <div class="stage glass mx-auto">
        <!-- 캔버스: 투명 배경 + 버튼 아래/위 관계 신경 안 쓰도록 pointer-events:none -->
        <canvas id="game" class="block mx-auto relative z-10 pointer-events-none"
                width="360" height="640" aria-label="똥피하기 게임 캔버스"></canvas>

        <!-- HUD (맨 위) -->
        <div class="absolute top-2 left-2 right-2 z-40 flex items-center justify-between">
          <div class="chip">점수 <span id="score" class="ml-1">0</span></div>
          <div class="chip">최고 <span id="high" class="ml-1">0</span></div>
        </div>

        <!-- 모바일 터치 (항상 보이도록 최상단) -->
        <div class="touch-zone">
          <button class="btn-glass touch-btn" id="leftBtn" aria-label="왼쪽으로 이동">←</button>
          <button class="btn-glass touch-btn" id="rightBtn" aria-label="오른쪽으로 이동">→</button>
        </div>
      </div>

      <div class="mt-3 text-center text-xs opacity-70">
        ←/→ 또는 A/D 이동 · P: 일시정지 · R: 다시시작
      </div>
    </section>

    <!-- 사용법 -->
    <section class="glass p-4">
      <h2 class="font-extrabold tracking-tight text-base mb-2">사용법</h2>
      <ul class="list-disc pl-5 text-sm leading-6">
        <li>아래쪽 캐릭터를 좌우로 움직여 작은 똥을 피하세요.</li>
        <li>시간이 지날수록 낙하 속도/빈도가 증가합니다.</li>
        <li>충돌 시 종료, 점수는 생존 시간입니다.</li>
      </ul>
    </section>
  </main>

  <!-- 결과 모달 -->
  <div id="resultModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="resultTitle">
    <div class="glass p-6 w-full max-w-[420px]">
      <h3 id="resultTitle" class="text-xl font-extrabold tracking-tight mb-3">게임 오버</h3>
      <div class="grid grid-cols-2 gap-2 text-sm">
        <div class="glass p-3 rounded-2xl text-center">
          <div class="text-[11px] uppercase tracking-wider opacity-70">점수</div>
          <div id="finalScore" class="font-extrabold text-lg tracking-tight">0</div>
        </div>
        <div class="glass p-3 rounded-2xl text-center">
          <div class="text-[11px] uppercase tracking-wider opacity-70">최고</div>
          <div id="finalHigh" class="font-extrabold text-lg tracking-tight">0</div>
        </div>
      </div>
      <div class="mt-5 flex justify-end gap-2">
        <button id="modalClose" class="btn-glass px-4 py-2">닫기</button>
        <button id="modalRestart" class="btn-glass px-4 py-2 font-semibold">다시하기</button>
      </div>
    </div>
  </div>

<script>
/**
 * 모바일 스크롤 방지 + 버튼 항상 보이기 버전
 * - 캔버스: 투명(알파) 배경, pointer-events:none
 * - 하단 버튼 z-30로 항상 표시
 * - 캐릭터 위치: 버튼 위(H-140)
 */
const HS_KEY = 'dodgyPooHigh_v4';

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha: true }); // 투명 캔버스
const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
initCanvas();

function initCanvas(){
  const w = 360, h = 640;
  canvas.width = w * DPR;
  canvas.height = h * DPR;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
}

// 상태/참조
let running = false, paused = false, over = false;
let last = 0, score = 0, high = Number(localStorage.getItem(HS_KEY) || 0);
const W = 360, H = 640;

const ui = {
  score: document.getElementById('score'),
  high: document.getElementById('high'),
  modal: document.getElementById('resultModal'),
  finalScore: document.getElementById('finalScore'),
  finalHigh: document.getElementById('finalHigh'),
  btnPause: document.getElementById('btnPause'),
  btnReset: document.getElementById('btnReset'),
  modalClose: document.getElementById('modalClose'),
  modalRestart: document.getElementById('modalRestart'),
  leftBtn: document.getElementById('leftBtn'),
  rightBtn: document.getElementById('rightBtn'),
};
ui.high.textContent = high;

// 캐릭터 (버튼 위)
const player = {
  x: W/2,
  y: H - 140,     // 버튼(72px)보다 확실히 위
  w: 56, h: 64,
  speed: 240,
  vx: 0,
};

// 똥들
const poos = [];
let spawnTimer = 0;
let spawnInterval = 700; // ms
let fallSpeed = 140;     // px/s
const GRAVITY = 220;
const MIN_INTERVAL = 250;

// 입력
const keys = { left:false, right:false };

// 터치: 스크롤 방지
['touchstart','touchend'].forEach(ev=>{
  ui.leftBtn.addEventListener(ev, e=>{ e.preventDefault(); }, {passive:false});
  ui.rightBtn.addEventListener(ev, e=>{ e.preventDefault(); }, {passive:false});
});
ui.leftBtn.addEventListener('touchstart', ()=> keys.left=true , {passive:false});
ui.leftBtn.addEventListener('touchend',   ()=> keys.left=false, {passive:false});
ui.rightBtn.addEventListener('touchstart',()=> keys.right=true , {passive:false});
ui.rightBtn.addEventListener('touchend',  ()=> keys.right=false, {passive:false});

// 전역 스와이프 스크롤 억제 (게임 영역에서만)
document.addEventListener('touchmove', (e)=>{
  if (e.target.closest('.stage')) e.preventDefault();
}, {passive:false});

// 버튼들
ui.btnPause.addEventListener('click', ()=> { if(!over) paused = !paused; });
ui.btnReset.addEventListener('click', restart);
ui.modalClose.addEventListener('click', ()=> ui.modal.classList.remove('show'));
ui.modalRestart.addEventListener('click', ()=> { ui.modal.classList.remove('show'); restart(); });

// 키보드
window.addEventListener('keydown', e=>{
  if (e.code==='ArrowLeft' || e.key==='a' || e.key==='A') keys.left = true;
  if (e.code==='ArrowRight'|| e.key==='d' || e.key==='D') keys.right = true;
  if (e.key==='p' || e.key==='P') { if(!over) paused = !paused; }
  if (e.key==='r' || e.key==='R') restart();
});
window.addEventListener('keyup', e=>{
  if (e.code==='ArrowLeft' || e.key==='a' || e.key==='A') keys.left = false;
  if (e.code==='ArrowRight'|| e.key==='d' || e.key==='D') keys.right = false;
});

// 시작
reset();
requestAnimationFrame(loop);

function reset(){
  running = true; paused = false; over = false;
  last = 0; score = 0;
  player.x = W/2; player.vx = 0;
  poos.length = 0;
  spawnTimer = 0;
  spawnInterval = 700;
  fallSpeed = 140;
  ui.score.textContent = 0;
  ui.high.textContent = high;
}

function restart(){
  ui.modal.classList.remove('show');
  reset();
}

function loop(t){
  if (!last) last = t;
  const dt = (t - last)/1000;
  last = t;

  if (running && !paused && !over){
    update(dt);
  }
  render();
  requestAnimationFrame(loop);
}

function update(dt){
  score += dt * 100;
  ui.score.textContent = Math.floor(score);

  fallSpeed += 10 * dt;
  spawnInterval = Math.max(MIN_INTERVAL, spawnInterval - 40 * dt);

  player.vx = (keys.left ? -1 : 0) + (keys.right ? 1 : 0);
  player.x += player.vx * player.speed * dt;
  const halfW = player.w/2;
  player.x = Math.max(halfW + 10, Math.min(W - halfW - 10, player.x));

  spawnTimer += dt*1000;
  if (spawnTimer >= spawnInterval){
    spawnTimer = 0;
    spawnPoo();
  }

  for (let i=poos.length-1;i>=0;i--){
    const p = poos[i];
    p.vy += GRAVITY * dt;
    p.y += (p.baseVy + p.vy) * dt;
    if (hitCircleRect(p.x, p.y, p.r, player.x - player.w/2, player.y - player.h/2, player.w, player.h)){
      gameOver(); return;
    }
    if (p.y - p.r > H) poos.splice(i,1);
  }
}

function render(){
  // 투명 캔버스이므로 매프레임 클리어만
  ctx.clearRect(0,0,W,H);

  // 바닥 그림자톤(시각적 기준선)
  ctx.fillStyle = 'rgba(17,24,39,0.06)';
  ctx.fillRect(0, H-18, W, 18);

  // 얇은 가이드선
  ctx.strokeStyle = 'rgba(17,24,39,0.05)';
  ctx.lineWidth = 1;
  for (let y=0;y<H;y+=32){ line(0,y,W,y); }

  // 캐릭터
  drawPlayer(player.x, player.y, player.w, player.h);

  // 똥들
  for (const p of poos){ drawPoo(p.x, p.y, p.r); }

  if (paused){
    ctx.fillStyle = 'rgba(17,24,39,0.28)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#111827';
    ctx.font = '900 28px Inter, sans-serif';
    ctx.textAlign='center';
    ctx.fillText('PAUSED', W/2, H/2);
  }
}

/* ==== 그리기/도우미 ==== */
function line(x1,y1,x2,y2){ ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }

function roundRectPath(x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
}

function drawPlayer(cx, cy, w, h){
  const x = cx - w/2, y = cy - h/2;

  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,0.18)';
  ctx.shadowBlur = 10;
  ctx.shadowOffsetY = 6;

  ctx.fillStyle = '#f3f4f6';
  roundRectPath(x, y, w, h, 14);
  ctx.fill();

  ctx.lineWidth = 3;
  ctx.strokeStyle = '#0f172a';
  ctx.stroke();

  // 얼굴
  ctx.shadowColor = 'transparent';
  ctx.fillStyle = '#0f172a';
  ctx.beginPath(); ctx.arc(cx-12, cy-8, 3.5, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx+12, cy-8, 3.5, 0, Math.PI*2); ctx.fill();

  ctx.lineWidth = 2.2;
  ctx.strokeStyle = '#2563eb';
  ctx.beginPath(); ctx.arc(cx, cy+10, 11, Math.PI*0.15, Math.PI- Math.PI*0.15); ctx.stroke();

  ctx.restore();
}

function drawPoo(x,y,r){
  const base = '#c8b49b';
  const mid  = '#b49e85';
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,0.12)';
  ctx.shadowBlur = 6;
  ctx.shadowOffsetY = 4;

  // 밑단
  ctx.fillStyle = base;
  ctx.beginPath();
  ctx.ellipse(x, y, r*1.2, r*0.7, 0, 0, Math.PI*2);
  ctx.fill();

  // 중단
  ctx.fillStyle = mid;
  ctx.beginPath();
  ctx.ellipse(x, y - r*0.6, r*0.9, r*0.55, 0, 0, Math.PI*2);
  ctx.fill();

  // 상단
  ctx.beginPath();
  ctx.moveTo(x, y - r*1.55);
  ctx.quadraticCurveTo(x + r*0.6, y - r*1.1, x + r*0.3, y - r*0.6);
  ctx.quadraticCurveTo(x, y - r*0.2, x - r*0.3, y - r*0.6);
  ctx.quadraticCurveTo(x - r*0.6, y - r*1.1, x, y - r*1.55);
  ctx.fill();

  // 하이라이트 + 외곽
  ctx.fillStyle = 'rgba(255,255,255,0.25)';
  ctx.beginPath(); ctx.ellipse(x + r*0.4, y - r*0.9, r*0.25, r*0.15, -0.6, 0, Math.PI*2); ctx.fill();
  ctx.lineWidth = 1.4; ctx.strokeStyle = 'rgba(17,24,39,0.35)';
  ctx.beginPath(); ctx.ellipse(x, y, r*1.2, r*0.7, 0, 0, Math.PI*2); ctx.stroke();

  ctx.restore();
}

function spawnPoo(){
  const r = rand(9, 14);
  const x = rand(12 + r, W - 12 - r);
  const y = -r - 10;
  const baseVy = fallSpeed + rand(-20, 24);
  poos.push({ x, y, r, baseVy, vy: 0 });
}

function hitCircleRect(cx, cy, cr, rx, ry, rw, rh){
  const nx = Math.max(rx, Math.min(cx, rx+rw));
  const ny = Math.max(ry, Math.min(cy, ry+rh));
  const dx = cx - nx;
  const dy = cy - ny;
  return dx*dx + dy*dy <= cr*cr;
}

function rand(min, max){ return Math.random()*(max-min)+min; }

function gameOver(){
  running = false; over = true;
  score = Math.floor(score);
  if (score > high){ high = score; localStorage.setItem(HS_KEY, String(high)); }
  ui.finalScore.textContent = score;
  ui.finalHigh.textContent = high;
  ui.high.textContent = high;
  ui.modal.classList.add('show');
}
</script>
</body>
</html>
